
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>

  <title>AI4Verification</title>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="description" content="AI4Verification is a group in Huawei">
  <meta name="keywords" content="ai4verification">
  <meta name="author" content="Wenyi Xiao" />

  <link rel="stylesheet" href="w3.css">

  <style>
  .w3-sidebar a {font-family: "Roboto", sans-serif}
  body,h1,h2,h3,h4,h5,h6,.w3-wide {font-family: "Montserrat", sans-serif;}
  </style>

  <link rel="icon" type="image/png" href="images/icons.png">
  <!--
  <script src="jquery.min.js"></script>
  <script>
  $(document).ready(function(){
    // Add smooth scrolling to all links
    $("a").on('click', function(event) {
      // Make sure this.hash has a value before overriding default behavior
      if (this.hash !== "") {
        // Prevent default anchor click behavior
        event.preventDefault();
        // Store hash
        var hash = this.hash;
        // Using jQuery's animate() method to add smooth page scroll
        // The optional number (800) specifies the number of milliseconds it takes to scroll to the specified area
        $('html, body').animate({
          scrollTop: $(hash).offset().top
        }, 800, function(){
          // Add hash (#) to URL when done scrolling (default click behavior)
          window.location.hash = hash;
        });
      } // End if
    });
  });
  </script>
  //-->

</head>


<body class="w3-content" style="max-width:1000px">

<!-- Sidebar/menu -->
<nav class="w3-sidebar w3-bar-block w3-black w3-collapse w3-top w3-right" style="z-index:3;width:150px" id="mySidebar">
  <div class="w3-container w3-display-container w3-padding-16">
    <h3><b>Verification</b></h3>
  </div>
  <div class="w3-padding-64 w3-text-light-grey w3-large" style="font-weight:bold">
    <a href="#home" class="w3-bar-item w3-button">Home</a>
    <a href="#news" class="w3-bar-item w3-button">Members</a>
    <a href="#Introduction" class="w3-bar-item w3-button">Introduction</a>
    <a href="#Progress" class="w3-bar-item w3-button">Progress</a>
    <a href="#Survey" class="w3-bar-item w3-button">Survey</a>
    <a href="#publications" class="w3-bar-item w3-button">Publications</a>
    <a href="#brainstorm" class="w3-bar-item w3-button">Brainstorm</a>
    <a href="#award" class="w3-bar-item w3-button">Awards</a>
  </div>
</nav>

<!-- Top menu on small screens -->
<header class="w3-bar w3-top w3-hide-large w3-black w3-xlarge">
  <div class="w3-bar-item w3-padding-24">AI4Verification</div>
  <a href="javascript:void(0)" class="w3-bar-item w3-button w3-padding-24 w3-right"  style="font-stretch: extra-expanded;" onclick="w3_open()"><b>≡</b></a>
  <!-- </div> -->
</header>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- !PAGE CONTENT! -->
<div class="w3-main" style="margin-left:150px">

  <!-- Push down content on small screens -->
  <div class="w3-hide-large" style="margin-top:83px"></div>

<!-- The Home Section -->
    <div class="w3-container w3-center w3-padding-32" id="home">
      <img style="width: 80%;max-width: 320px" alt="profile photo" src="images/group_photo.png">
      <img style="width: 40%;max-width: 120px" alt="profile photo" src="images/yuanmingxuan.png">
      <img style="width: 40%;max-width: 220px" alt="profile photo" src="images/haojianye.png">
      <h1>AI4Verification</h1>
        <p class="w3-justify" style="width:100%;border:0px;border-spacing:0px;border-collapse:separate;margin-right:auto;margin-left:auto;max-width:600px">
          Many EDA applications can be abstracted into SAT problems and then directly call the SAT solver to solve them, including Model Checking (MC), Logic Synthesis, Logic Equivalence Checking (LEC), Automatic Test Pattern Generation (ATPG), etc. However, high-performance SAT solvers are often not equivalent to the fact that the actual EDA problem can be solved efficiently. The reasons include high-quality coding (modeling) methods in complex constraint scenarios, solution-friendly simplification methods, and data-matched Solver or solution algorithm selection, etc. 
        </p>
        <p class="w3-center">
          <a href="mailto:Noah_AI4EDA@gmail.com">Email</a> 
        </p>
        </tbody></table>
  </div>

<!-- The News Section -->
  <div class="w3-container w3-light-grey w3-padding-32" id="news">
   <h2>成员介绍</h2>
   All of us are working on SAT-related algorithms in EDA, such as Automatic Test Pattern Generation (ATPG), Logic Equivalence Checking (LEC), Model Checking (MC). We all focus on both modeling and solving in practice.
      <p><li> Dr. Mingxuan Yuan | <a style="color: #447ec9" href="https://dblp.org/pid/74/2356.html">DBLP</a>：PhD on data mining, data management, machine learning, etc. Now he is the project manager of AI4EDA in Noah's Ark Lab, Huawei. </li></p>
      <p><li> Dr. Hui-Ling Zhen | <a style="color: #447ec9" href="https://scholar.google.com.hk/citations?user=gq29DtwAAAAJ&hl=zh-CN">google scholar</a>: PhD on Numerical PDE, large scale optimization, and large scale constraint optimization. Now she is working on incremental SAT solving, ATPG, approximation in BMC, ATPG for LEC, etc.</li></p>
      <p><li> Dr. Wenyi Xiao | <a style="color: #447ec9" href="https://scholar.google.com/citations?user=4sgCmJIAAAAJ&hl=en">google scholar</a>: PhD on data mining, recommendation system. Now she is working on adaptive LEC algorithm, and graph embedding on EDA problems. </li></p>
      <p><li> Dr. Lihao Yin | <a style="color: #447ec9" href="https://scholar.google.com/citations?user=bS9oH_oAAAAJ&hl=en">google scholar</a>: PhD on Applied mathematics and statistics. Now he is working on incremental MC algorithms, property grouping-based verification, latch correspondence, fix-point algorithm in PDR and word-level verification, etc. </li></p>
      <p><li> Wanqian Luo | <a style="color: #447ec9" href="https://github.com/">Github</a>: luowanqian Master in CS. Now he is working on circuit SAT, parallel SAT solving, bandit for clause sharing, incremental LEC,adaptive modeling in LEC, etc. </li></p>
      <p><li> Junhua Huang | <a style="color: #447ec9" href="https://scholar.google.com/citations?user=pFOIOJ0AAAAJ&hl=zh-CN">google scholar</a>: Master in combinatorial optimization. Now she is working on efficient reverse simulation in SAT sweeping, and related application in logic synthesis and LEC. </li></p>
      <p><li> Tsz Ho Chan | <a style="color: #447ec9" href="https://www.linkedin.com/in/tsz-ho-chan-320015233/?originalSubdomain=hk">Linkedin</a>: Master in Computer Science, HKUST. Now he is working on graph model and representation learning, and their applications in SAT solving and equivalence checking. </li></p>

 <h4><li>Some of our kindly partners:</li></h4>
      <p><li> Prof. Jianye Hao | <a style="color: #447ec9" href="https://scholar.google.com/citations?user=FCJVUYgAAAAJ&hl=zh-CN">google scholar</a>: PhD on reinforcement learning and multi-agent system. Now he is the director of decision and reasoning lab of Noah's Ark Lab, Huawei. </li></p>
      <p><li> Dr. Jia Zeng | <a style="color: #447ec9" href="https://dblp.org/pid/31/435.html">DBLP</a>: PhD on machine learning. He also has industrial experience on operation research and supply chain management. Now he is a project manager in Noah's Ark Lab, Huawei. </li></p>
      <p><li> Dr. Yu Huang | <a style="color: #447ec9" href="https://scholar.google.com/citations?user=acPTiEQAAAAJ&hl=en">google scholar</a>: PhD on DFT, and more than 20 years experience on industrial DFT, such as diagnosis, compression, compaction, scan chain test, etc. </li></p>
      <p><li> Dr. Naixing Wang | <a style="color: #447ec9" href="https://scholar.google.com/citations?user=c_R21V8AAAAJ&hl=en">google scholar</a>: PhD on DFT. Several years experience on industrial DFT, such as ATPG, TPI, etc. </li></p>
      <p><li> Yingxue Zhang | <a style="color: #447ec9" href="https://scholar.google.com/citations?user=4bsYpogAAAAJ&hl=en">google scholar</a>: Years of experience on graph networks and representation learning.  </li></p>
  </div>


<!-- The Projects Section -->
  <div class="w3-container w3-padding-32" id="Introduction">
    <h2>SAT in Industrial EDA Problems</h2>
    <p class="w3-justify">
	    Boolean Satisfiability (or called SAT for short) is the problem of determining if there exists an interpretation that satisfies a given Boolean formula. In other words, it asks whether the variables of a given Boolean formula can be consistently replaced by the values TRUE or FALSE in such a way that the formula evaluates to TRUE. If this is the case, the formula is called satisfiable, otherwise, it is unsatisfiable. Modern SAT solver depends on Conflict-driven Clause Learning (CDCL) algorithm. 
    </p>

              <h4><li>Development of Boolean Satisfiability</li></h4>
        <img style="width:96%;" src="images/Timeline.png">
        <p class="w3-justify">
      Before 2012: Several research has been done on circuit SAT as well as the combination between ATPG and SAT. ATPG has shown certain advantage on solving sequential equivalence checking during the requirement-driven searching strategy and activity-based modeling method. In MC, word-level research has started. Intel has proposed a commerial ATPG engine with SAT-reasoning module. In ATPG, PASSAT has been proposed which enables the SAT-based ATPG in industrial applications. In LEC, bundle method (an incremental LEC method) has been proved the better efficiency. There are two major events: 1) one is that the SAT competition began to be normalized and is held every year after 2002; 2) the other one is that there is the  <strong> first patent</strong> (as far as our knowledge) for data-driven LEC engine, and it is worth mentioning that <strong> the improved data-driven LEC architectur has appeared in the Formality's white paper </strong> in 2021. 
      </p>
      <p class="w3-justify">
      2013-2018: 1. Cube-and-conquer was proposed for SAT solving: based on this framework, the performance of parallel proofs on some data is better than serial ones; 2. More and more improvement of SAT-based proofs focuses on encoding. 3. Algebra and theory proving has began to be used in the LEC of datapath circuit, especially for proving multiplier. 4. More learning-based proof schemes have been proposed in LEC and MC: a) Adaptive scheme selection has become a general pipeline in many patents and white paper. b) For hard bug finding cases, reinforcement learning and MDP methods have been utilized for path finding. It is worth mentioning that the <strong> first learning-based SAT solver </strong> network, or called NeuroSAT, has been proposed. The basic network consists of two parts, a GNN-based network to get the representation vector, and a classifier to predict. Its aim is to predict whether the problem is SAT or UNSAT. After that, most of the learning-aided SAT solvers follow this architecture. 
             </p>
      <p class="w3-justify">
      From 2019 to now: More and more researches are conducted on <strong> data augmentation </strong>. The key insight is to improve the quality of trained model by improving data diverity and sample complexity. More white papers on industrial verification tool, such as conformal and vso.ai, has claimed the effect of learning methods. Reverse engineering has been utilized in LEC, aiming to improve the proof efficiency of datapath circuit. Kissat has won the SAT competition in 2020. From then on, more and more SAT solvers follow Kissat's architectur. In 2022, the golden SAT solver has used bandit for algorithm selection based on the data structure of the original Kissat.
        </p> 

      <h4><li>Symbolic or Structural?</li></h4>
            <img style="width: 95%;max-width: 320px" src="images/cnfgeneration.png">
            <p class="w3-justify">
      On the one hand, SAT solvers are continuously improving their performance. The latest SAT solvers try to infer possible circuit structure information in CNF, thereby enhancing the correctness of decision-making. SAT solvers serve as the basic engines in industrial EDA, such as ATPG, LEC, MC, routing, etc. This is partly due to the efficiency of symbolic computation in dealing with NP-hard problems, especially the efficient reasoning between Boolean variables. 
      </p>

      <p class="w3-justify">
      On the other hand, The SAT problem is completely different from the domain of the EDA problem. The latter is defined on the circuit and often has scene-specific constraints, such as the diagnosis resolution and compression-aware considered in ATPG. In MC, it is often necessary to know the situation of each PO. If it is not found that a PO is unsafety (that is, corresponding to the SAT problem), the solution will be exited. Two bottlenecks often happen in SAT's applications in industrial EDA. 1) Modeling time cost much. Take ATPG as an example, the transformation time from circuit to CNF is usually longer than solving time. 2) Low reasoning efficiency due to the learning-from-mistakes framework. A lot of structural information is too difficult to embed in symbolic expressions. In the research of SAT community, a very important direction is to introduce structural information into expressions through means such as simulation (on RTLIL or netlist) in the early stage.  
       </p>

      <h4><li>SAT-related Problem in EDA</li></h4>
      <p class="w3-justify">
      We have summarized several problems that an efficient SAT-based solution may face, if you are also interested in these problems, welcome to email us.
       </p>

        <img style="width:94%;" src="images/satproblem.png"> 
       <ol>

      <p><li> <strong>Effective modeling.</strong> We aim at "effective", not only efficient, the reason lies in the possible loss of structural information of SAT boolean formulas. In this problem, we mainly consider how to preserve the structural properties of the circuit itself, and further effectively identify the implicit constraints that correctly define the search space and put them into the model.  </li></p>

      <p><li> <strong>Adaptive preprocessing.</strong> There is an underlying assumption here that, in a general-purpose solver, a smaller model usually means a relatively higher probability of being efficiently proved UNSAT, or finding a set of legal assignments. Therefore, we always hope to add a suitable pre-solution module between modeling and solving. Neither will it bring a performance burden due to additional calculations, nor will it limit the accuracy of decision-making due to the size of the model. Especially in Model Checking, we found that efficient latch correspondece or retiming and speculation technologies can always relieve the pressure of state explosion to a certain extent, thereby improving the proof or solution performance. </li></p>

      <p><li> <strong> Adaptive distributed solving scheme.</strong> From the perspective of the SAT community, the performance of the SAT solver itself is greatly improved every year. However, in industrial practice, we do find that the solution performance is not always equivalent to the ranking of the SAT competition, and different problems always have their own solvers. How to efficiently use different solvers to complete adaptive parallel or distributed systems is an important problem to be solved urgently. Furthermore, for a hard case, <strong> if any single solver cannot solve it, how to complete an efficient portfolio strategy </strong> through information interaction between different solvers is our top priority. </li></p>

      <p><li> <strong>Efficient simulation.</strong> Here we assume that we always carry out the proof flow from a high-level language to a mathematical/boolean expression. How to obtain important semantic information from higher-level models (such as RTLIL or netlist) and efficiently use semantic information to complete decision-making and search is one of the important research directions. </li></p>

      <p><li> <strong>Effective data augmentation.</strong> We certainly believe that AI can contribute to the solution and proof of SAT. However, we also admit that the current stable application of AI to industrial scenarios faces many challenges such as stability and generalization. How to  <strong> improve the quality of the current training data through data augmentation </strong>, so as to improve sample complexity and enhance generalization, is the first problem to be solved. Many people have already begun to pay attention to this direction. But from the perspective of SAT, the biggest problem we need to face is that <strong> the similarity of the model does not match the similarity of the solution space </strong>. That is to say, we can cite many examples to prove that even if the similarity of the two models has exceeded 99% (for example, only one constraint is inconsistent among the variables of tens of millions of scales), they can be a SAT problem, an UNSAT problem, and a It only takes 10 seconds to solve, while one takes more than 20,000 seconds. How to define an effective measurement to determine the similarity is a priority problem to be solved here. </li></p>

      <p><li> <strong>Pretrained model.</strong> In order to maximize the use of expert knowledge and data, we care whether there can be a pre-trained model to enhance the infrastructure in the current AI-based framework. If possible, we can migrate to different tasks through incremental training in the future, which not only effectively shortens the training time, but also completes information fusion in different directions through the model to make up for the short-sightedness and limitations of expert knowledge in local directions. </li></p>

      <p><li> <strong>Efficient online fine-tuning techniques.</strong> From the perspective generalization, we would like to further enhance the generalization by combining online fun-tuning, so as to improve the prediction accuracy of the model in different scenarios. We consider the appropriate fine-tuning indicators, efficient fine-tuning technology, etc. </li></p>

    </ol>
        
  <div class="w3-container w3-light-grey w3-padding-32" id="Progress">
    <h2>Recent Progress</h2>
    
  <p class="w3-justify">
    <p><li> 2021-Incremental SAT-based ATPG framework with simulation-based preprocessing. Considering the effect of scale, we also implemente the cube-and-conquer to improve solving strategy. To improve the modeling efficiency, the fault clustering is also considered. The related paper has been published in ASP-DAC-2021 | <a style="color: #447ec9" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9712573">paper</a>.  </li></p>
    <p><li> 2022-Generative model, which is armed with partition and merge, has been trained for data augmentation, the  synthetic data is utilized to strenghen the learned NeuroSAT for algorithm selection in ATPG. The related paper has been published in ITC-2022 | <a style="color: #447ec9" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9983862">paper</a>. </li></p>
    <img style="width:90%;" src="images/ganforatpg.png">

    <p><li> 2022-Shift-left framework has been utilized in SAT-based ATPG. Conflict-driven Strutural Learning has been implemented in ATPG. The related paper has been published in ETS-2023 | <a style="color: #447ec9" href="https://arxiv.org/pdf/2303.02290.pdf">paper</a>. </li></p>
    <img style="width:90%;" src="images/conflict_driven_atpg.png">

    <p><li> 2022-A generalized version on data augmentation is implemented in LEC. In this work, we consider to utilize the perturbation techniques to improve the similarity between synthetic and original data. More than 10% improvement on solving efficiency has been got on multiplier verification. The related paper has been reviewed in KDD-2023. </li></p>
    <img style="width:96%;" src="images/ganforlec.png">

    <!-- <p><li> 2022-A transformer-based learning-aided SAT solver, SATformer, has been implemented. Different from the NeuroSAT pipeline, a hierarchical Transformer architecture is applied on the clause embeddings to capture the relationships among clauses, and the self-attention weight is learned to be high when those clauses forming UNSAT cores are attended together, and set to be low otherwise. The related paper has been submited to ICCAD-2023. </li></p> -->

    <!-- <p><li> 2023-Functionality-aware Circuit Learning Model has been completed. The model is trained to predict the functional similarity between node pairs within the same circuit. Several keypoints are considered here. 1) A functionality-aware loss function is constructed to minimize the error between pairwise truth table hamming distance and node embedding distance. 2) The node embedding distance is calculated based on the cosine similarity of two node embedding vectors. 3) A one-round GNN is trained for both structural and functional features, and to improve the training efficiency, we assign several orthogonal vectors as the initial embeddings for PIs. An intuitive explanation should be that the purpose is to determine whether two nodes are reconvergent by recording whether they share one or multiple common PIs. The related paper has been submited to ICCAD-2023. </li></p>
      </p> -->
  </div>
	
  <!-- The Talks Section -->
  <div class="w3-container w3-padding-32" id="Survey">
  <h2>Survey</h2>

	<h4><li>NeuroSAT and learning-aided SAT Pipeline</li></h4>
	<p class="w3-justify">
    <ol>
    <p><li> The first learning-aided SAT solver, <a style="color: #447ec9" href="https://github.com/dselsam/neurosat"><strong> NeuroSAT </strong></a>,  has been proposed in 2018. Its core is a message passing neural network that learns to solve SAT problems after only being trained as a classifier to predict satisfiability. The trained network learns to detect the contradictions instead of searching for satisfying assignments. When the number of variables involved in the contradiction is small relative to the total number of variables, knowing which variables are involved in the contradiction can enable constructing a resolution proof more efficiently. </li></p>
    <img style="width:90%;" src="images/neurosat.png">

    <p><li> The generalized form, <a style="color: #447ec9" href="https://github.com/dselsam/neurocore-public"><strong> NeuroCore </strong></a>, is trained to predict the unsatisfiable cores of UNSAT problems. The predicted results, how likely the variables are to appear in an unsatisfiable core, are periodically used to replace the variable activity scores in SAT solvers.  </li></p>
    <img style="width:90%;" src="images/neurocore.png">

    <p><li> Reinforcement learning has been first utilized for improving SAT in <a style="color: #447ec9" href="https://proceedings.neurips.cc/paper/2020/file/6d70cb65d15211726dcce4c0e971e21c-Paper.pdf"><strong> Graph-Q-SAT </strong></a>. It uses a graph representation of SAT problems similar as NeuroSAT, which provides permutation and variable relabeling invariance. The update process is based on a trained DQN, which is a value-based RL algorithm that approximates an optimal Q-function. Hereby, the action-value function is used to estimate the sum of future rewards after taking an action a in state s and following an optimal policy thereafter. </li></p>

    <p><li> Since 2021, many testing and verification products have been armed with AI methods, featuring machine learning technology and core formal technology enhancements. For example, Formality and Conformal both claim to use the data driven method to realize an adaptive distributed proof method based on multiple solvers. Jasergold claims to utlilize AI method to select and parameterize solvers to enable faster first-time proofs. Meanwhile, machine learning is used to optimize successive runs for regression testing, either on premises or in the cloud. But the solver is primarily viewed as a black box, without any adaptive processing of searching as well as decision methods inside the solver.  </li></p>

  </ol>
        

	<h4><li>Data Augmentation and Generative Models </li></h4>
	<ol>
	<p><li> The first implicit model that generates Boolean Satisfiability formulas which resemble instances that arise in real-world industrial settings has been present, <a style="color: #447ec9" href="https://ojs.aaai.org/index.php/SOCS/article/view/18493"><strong> Learning to generate SAT instance </strong></a>. It uses the unsupervised techniques to create new formulas by mimicking the structural properties of a given input formula. There are two phases. A Literal Incidence Graph (LIG) has been firstly constructed, and Generative Adversarial Network is trained to generate new LIGs that exhibit graph-theoretic properties similarly. Secondly, the generated graph is extracted to finding a minimal clique edge cover of the given graph, which we tackle efficiently using a greedy hill-climbing algorithm. </li></p>

  <p><li> To tackle with the large scale, <a style="color: #447ec9" href="https://snap.stanford.edu/g2sat/"><strong> G-SAT </strong></a> has been proposed. The key insight is that any bipartite graph can be generated by starting with a set of trees, and then applying a sequence of node merging operations over the nodes from one of the two partitions. As we merge nodes, trees are also merged, and complex bipartite structures begin to appear. In this manner, a set of input bipartite graphs (SAT formulas) can be characterized by a distribution over the sequence of node merging operations. The G2SAT is trained via such a process. </li></p>

  <img style="width:90%;" src="images/g2sat.png">

  <p><li> To further tackle with the difference between structural similary and searching path, our paper HardSATGEN has been submited to KDD-2023. The related experiments have been conducted on LEC, and more than 10% improvement on solving efficiency has been obtained. More details will be given after publishment. </li></p>
 	</ol> 

  <h4><li>Seletect Patent </li></h4>
  <ol>
  <p><li> (Synopsys-2013)-<strong>Formal Verification Result Prediction</strong>. The first patent for data-driven algorithm selection and proving strategy order prediction. The feature is extracted from AIG data, clause graph as well as propagation features, learnt clause features, etc. The scheduling includes an order for executing the verification engines on a specific design problem where the order may be determined based on the feature data. </li></p>
  <img style="width:90%;" src="images/patent_select_formal.png">

  <p><li> (Intel-1999)-<strong> Method and apparatus for scan design using a formal verification based process</strong>. The key point here is that ATPG works as a basic engine for model checking. The whole method also includes reading one or more vector generation targets, and performing word-level ATPG justification on the control logic component to obtain a control logic solution. The method further includes extracting one or more arithmetic functions for the datapath logic component based on the control logic Solution, and solving the one or more arithmetic functions using a modular constraint solver. </li></p>

  <p><li> (Synopsys-2021)-<strong> Accelerate formal property verification across design versions using sequential equivalence checking (SEC) </strong>. Using SEC techniques to improve formal property verification. Smart decomposition is conducted and the proving is in an incremental manner. Order is designed in proving different properties, for making most use of semantic information. </li></p>
  <img style="width:90%;" src="images/sec4fpv.png">

  <p><li> (Synopsys-2021)-<strong> Automated debug of falsified power-aware formal properties using static checker results</strong>. A power intent specification specifies the desired power intent for a design of an integrated circuit , for example the states of the power domains under different conditions . Power-aware formal properties describe desired behaviors specified by the power intent specification. In addition, a debug context database contains debug contexts for static-check violations resulting from power-aware static checking of the design. Static checking checks for compliance with the power intent specification based on a static structure of the design. </li></p>
  <img style="width:50%;" src="images/estimation_before_mc.png">
  
  </ol>
        
  <!-- </div> -->


 <!-- The Publications Section -->
  <div class="w3-container w3-padding-32"" id="publications">
    <h2>Publication</h2>
      <p class="w3-left-align" style="line-height:200%">
	Some of our works on optimization techniques and AI-related methods.
      </p>
    <h4> Optimization for Industrial EDA:</h4>

    <ol>

      <p>
      <li><strong>Accelerate sat-based atpg via preprocessing and new conflict management heuristics </strong>
      <br> Junhua Huang, Hui-Ling Zhen, Naixing Wang, Mingxuan Yuan, Hui Mao, Yu Huang, Jiping Tao <br>
      <em>ASP-DAC</em> 2021 | <a style="color: #447ec9" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9712573">paper</a> </p>

      <p>
      <li><strong>Conflict-driven Structural Learning Towards Higher Coverage Rate in ATPG</strong>
      <br> Hui-Ling Zhen, Naixing Wang, Junhua Huang, Xinyue Huang, Mingxuan Yuan, Yu Huang <br>
      <em>ETS</em> 2023 | <a style="color: #447ec9" href="https://arxiv.org/pdf/2303.02290.pdf">paper</a> </p>

      <p>
      <li><strong>A survey for solving mixed integer programming via machine learning</strong>
      <br> Jiayi Zhang, Chang Liu, Xijun Li, Hui-Ling Zhen, Mingxuan Yuan, Yawen Li, Junchi Yan <br>
      <em>Neurcomputing</em> 2022 | <a style="color: #447ec9" href="https://www.sciencedirect.com/science/article/pii/S0925231222014035">paper</a> </p>

      <p>
      <li><strong>Machine learning methods in solving the boolean satisfiability problem</strong>
      <br> Wenxuan Guo, Junchi Yan, Hui-Ling Zhen, Xijun Li, Mingxuan Yuan, Yaohui Jin <br>
      <em>Machine Intelligence Research</em> 2022 | <a style="color: #447ec9" href="https://arxiv.org/pdf/2203.04755.pdf">paper</a> </p>

      </ol>

      <h4> AI-related SAT and Constraint Optimization:</h4>

      <ol>

      <p>
      <li><strong>Neural Fault Analysis for SAT-based ATPG</strong>
      <br> Junhua Huang, Hui-Ling Zhen, Naixing Wang, Hui Mao, Mingxuan Yuan, Yu Huang <br>
      <em>ITC</em> 2022 | <a style="color: #447ec9" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9983862">paper</a> </p>

      <p>
      <li><strong>Layout Decomposition via Boolean Satisfiability</strong>
      <br> Hongduo Liu, Peiyu Liao, Mengchuan Zou, Bowen Pang, Xijun Li, Mingxuan Yuan, Tsung-Yi Ho, Bei Yu <br>
      <em> ACM/IEEE Design Automation Conference (DAC)</em> 2022 | To be appeared online soon </p>

      <p>
      <li><strong>Learning to select cuts for efficient mixed-integer programming</strong>
      <br> Zeren Huang, Kerong Wang, Furui Liu, Hui-Ling Zhen, Weinan Zhang, Mingxuan Yuan, Jianye Hao, Yong Yu, Jun Wang <br>
      <em>Pattern Recognition</em> 2022 | <a style="color: #447ec9" href="https://www.sciencedirect.com/science/article/pii/S0031320321005331">paper</a> </p>

      <p>
      <li><strong>Branch Ranking for Efficient Mixed-Integer Programming via Offline Ranking-Based Policy Learning</strong>
      <br> Zeren Huang, Wenhao Chen, Weinan Zhang, Chuhan Shi, Furui Liu, Hui-Ling Zhen, Mingxuan Yuan, Jianye Hao, Yong Yu, Jun Wang <br>
      <em>ECML-PKDD</em> 2022 | <a style="color: #447ec9" href="https://2022.ecmlpkdd.org/wp-content/uploads/2022/09/sub_543.pdf">paper</a> </p>

      <p>
      <li><strong>Pareto multi-task learning</strong>
      <br> Xi Lin, Hui-Ling Zhen, Zhenhua Li, Qing-Fu Zhang, Sam Kwong <br>
      <em>NeurIPS</em> 2019 | <a style="color: #447ec9" href="https://proceedings.neurips.cc/paper/2019/file/685bfde03eb646c27ed565881917c71c-Paper.pdf">paper</a> </p>

      </ol>

    </p>
  </div>

 <!-- The BrainStorm Section -->												  
 <div class="w3-container w3-light-grey w3-padding-32" id="N=brainstorm">
    <h2>Brainstorm</h2>
      <p><li> Both algorithm selection and solver recomendation can be implemented in industrial formal verification.</p> 

      <p><li> Incremental verification based on the property and simulated constraints is tried on model checking.</p> 

      <p><li> Fault clustering-based parallel framework and multi-target pattern generation can be both contributed to the pattern property and solving efficiency.</p> 
  </div>

  <!-- The Awards Section -->
  <div class="w3-container w3-padding-32" id="award">
    <h2>Awards</h2>
    <p><li> 2022-Company Annual Work Meeting Award-Innovation & Technological Breakthrough Award, Huawei. </a></p>               
    <p><li> 2022-All of us are part of the Gold Medal Team, Huawei. </a></p>  
  </div>  

  <div class="w3-light-grey w3-center w3-padding-24">

    Welcome to use this website's <a href="https://github.com/ai4verification/ai4verification.github.io">source code</a>, just add a link back to here. <a href="https://github.com/ai4verification/ai4verification.github.io">&#10025;</a></br>

  <!-- Default Statcounter code for Yunhe Wang's Homepage
  https://www.wangyunhe.site -->
  No.
  <script type="text/javascript">
  var sc_project=12347113; 
  var sc_invisible=0; 
  var sc_security="21aca5d1"; 
  var sc_https=1; 
  var scJsHost = "https://";
  document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+
  "statcounter.com/counter/counter.js'></"+"script>");
  </script> Visitor Since Feb 2022. Powered by <a href="https://www.w3schools.com/w3css/default.asp" title="W3.CSS" target="_blank" class="w3-hover-opacity">w3.css</a>
  <noscript>
    <div class="statcounter"><a title="Web Analytics Made Easy -
  StatCounter" href="https://statcounter.com/" target="_blank"><img
  class="statcounter" src="https://c.statcounter.com/12347113/0/21aca5d1/0/"
  alt="Web Analytics Made Easy - StatCounter"></a></div>
  </noscript>
  <!-- End of Statcounter Code -->

  </div>

  <!-- End page content -->
</div>

<script>
// Accordion 
function myAccFunc() {
  var x = document.getElementById("demoAcc");
  if (x.className.indexOf("w3-show") == -1) {
    x.className += " w3-show";
  } else {
    x.className = x.className.replace(" w3-show", "");
  }
}

// Click on the "Jeans" link on page load to open the accordion for demo purposes
document.getElementById("myBtn").click();


// Open and close sidebar
function w3_open() {
  document.getElementById("mySidebar").style.display = "block";
  document.getElementById("myOverlay").style.display = "block";
}
 
function w3_close() {
  document.getElementById("mySidebar").style.display = "none";
  document.getElementById("myOverlay").style.display = "none";
}
</script>

</body>
</html>
